diff --git a/src/comm.c b/src/comm.c
index 5f4af8a..d6253f0 100644
--- a/src/comm.c
+++ b/src/comm.c
@@ -58,7 +58,7 @@ struct comm comms[RC_LAST + 1] =
 #endif
   { "allpartial",	NEED_DISPLAY|ARGS_1 },
   { "altscreen",	ARGS_01 },
-  { "at",		ARGS_2|ARGS_ORMORE },
+  { "at",		CAN_QUERY|ARGS_2|ARGS_ORMORE },
 #ifdef COLOR
   { "attrcolor",	ARGS_12 },
 #endif
@@ -179,6 +179,7 @@ struct comm comms[RC_LAST + 1] =
   { "digraph",		NEED_LAYER|ARGS_012 },
   { "dinfo",		NEED_DISPLAY|ARGS_0 },
   { "displays",		NEED_LAYER|ARGS_0 },
+  { "dumpscreen",       ARGS_23 },
   { "dumptermcap",	NEED_FORE|ARGS_0 },
   { "echo",		CAN_QUERY|ARGS_12 },
 #ifdef ENCODINGS
@@ -194,7 +195,7 @@ struct comm comms[RC_LAST + 1] =
   { "focus",		NEED_DISPLAY|ARGS_01 },
   { "focusminsize",	ARGS_02 },
   { "gr",		NEED_FORE|ARGS_01 },
-  { "group",            NEED_FORE|ARGS_01 },
+  { "group",            CAN_QUERY|NEED_FORE|ARGS_01 },
   { "hardcopy",		NEED_FORE|ARGS_012 },
   { "hardcopy_append",	ARGS_1 },
   { "hardcopydir",	ARGS_01 },
@@ -274,6 +275,7 @@ struct comm comms[RC_LAST + 1] =
 #endif
   { "readreg",          ARGS_0|ARGS_ORMORE },
   { "redisplay",	NEED_DISPLAY|ARGS_0 },
+  { "regionsize",      CAN_QUERY|NEED_DISPLAY|ARGS_0 },
   { "register",		ARGS_24 },
   { "remove",		NEED_DISPLAY|ARGS_0 },
 #ifdef COPY_PASTE
@@ -284,7 +286,7 @@ struct comm comms[RC_LAST + 1] =
   { "resize",		NEED_DISPLAY|ARGS_0|ARGS_ORMORE },
   { "screen",		ARGS_0|ARGS_ORMORE },
 #ifdef COPY_PASTE
-  { "scrollback",	NEED_FORE|ARGS_1 },
+  { "scrollback",	NEED_FORE|ARGS_01 },
 #endif
   { "select",		CAN_QUERY|ARGS_01 },
   { "sessionname",	ARGS_01 },
@@ -313,6 +315,7 @@ struct comm comms[RC_LAST + 1] =
   { "terminfo",		ARGS_23 },
   { "time",		CAN_QUERY|ARGS_01 },
   { "title",		CAN_QUERY|NEED_FORE|ARGS_01 },
+  { "tty",		CAN_QUERY|ARGS_0 },
   { "umask",		ARGS_1|ARGS_ORMORE },
   { "unbindall",	ARGS_0 },
   { "unsetenv",		ARGS_1 },
diff --git a/src/fileio.c b/src/fileio.c
index 88fbf64..babf0e1 100644
--- a/src/fileio.c
+++ b/src/fileio.c
@@ -452,6 +452,23 @@ int dump;
       if (hardcopy_append && !access(fn, W_OK))
 	mode = "a";
       break;
+    case DUMP_SCSWINDOW:
+      if (fore == 0)
+        return;
+      else if (fn == 0)
+        return;
+      mode = (!access(fn, W_OK)) ? "a" : "w";
+      break;
+    case DUMP_SCSWINDOWFULL:
+      if (fore == 0)
+        return;
+      if (fn && *fn && strlen(fn) < sizeof(fnbuf) - 21)
+        sprintf(fnbuf, "%s/win_%d", fn, fore->w_number);
+      else
+        return;
+      fn = fnbuf;
+      mode = "w";
+      break;
 #ifdef COPY_PASTE
     case DUMP_EXCHANGE:
       if (fn == 0)
@@ -550,6 +567,33 @@ int dump;
 		  putc('\n', f);
 		}
 	      break;
+            case DUMP_SCSWINDOW:
+            case DUMP_SCSWINDOWFULL:
+                {
+                  char buf[1024];
+                  char *tty=NULL;
+                  if (!fore)
+                    break;
+                  if (fore->w_type == W_TYPE_TELNET)
+                    tty=SaveStr("telnet");
+                  else if (fore->w_type == W_TYPE_GROUP)
+                    tty=SaveStr("group");
+                  else
+                    if (strlen(fore->w_tty)==0)
+                      tty=SaveStr("zombie");
+                    else
+                      tty = (dump == DUMP_SCSWINDOW) ? fore->w_tty : "basic";
+                  if (dump == DUMP_SCSWINDOW)
+                    {
+                      sprintf(buf,"%d %d %s %s\n",fore->w_number,(fore->w_group) ? fore->w_group->w_number: -1, tty, fore->w_title);
+                    }
+                  else
+                    {
+                      sprintf(buf,"%d\n%s\n%d %s\n%s\n%s\n%s\n%d\n",fore->w_number,"\0", (fore->w_group) ? fore->w_group->w_number: -1, (fore->w_group) ? fore->w_group->w_title : "", tty ,fore->w_title,  fore->w_pwin ? fore->w_pwin->p_cmd : "-1", fore->w_histheight);
+                    }
+                  fprintf(f, buf);
+                }
+              break;
 	    case DUMP_TERMCAP:
 	      if ((p = index(MakeTermcap(fore->w_aflag), '=')) != NULL)
 		{
@@ -586,6 +630,10 @@ int dump;
 	  Msg(0, "Screen image %s to \"%s\".",
 	      (*mode == 'a') ? "appended" : "written", fn);
 	  break;
+        case DUMP_SCSWINDOW:
+        case DUMP_SCSWINDOWFULL:
+          Msg(0, "screen-session window dump written to \"%s\".",fn);
+          break;
 #ifdef COPY_PASTE
 	case DUMP_EXCHANGE:
 	  Msg(0, "Copybuffer written to \"%s\".", fn);
diff --git a/src/layout.c b/src/layout.c
index 196d10b..450417c 100644
--- a/src/layout.c
+++ b/src/layout.c
@@ -33,6 +33,7 @@
 
 extern struct display *display;
 extern int captionalways;
+extern int focusminwidth, focusminheight;
 
 struct layout *layouts;
 struct layout *laytab[MAXLAY];
@@ -166,6 +167,8 @@ struct canvas *cv;
     }
   while (D_canvas.c_slperp)
     FreeCanvas(D_canvas.c_slperp);
+  focusminwidth = lay->lay_focusminwidth;
+  focusminheight = lay->lay_focusminheight;
   D_cvlist = 0;
   D_forecv = lay->lay_forecv;
   DupLayoutCv(&lay->lay_canvas, &D_canvas, 0);
@@ -369,3 +372,42 @@ char *filename;
   return 1;
 }
 
+int
+dump_canvas_scs(cv, file)
+struct canvas *cv;
+FILE *file;
+{
+  struct canvas *c;
+  struct win *p;
+  int count=0;
+  
+  for (c = cv->c_slperp; c; c = c->c_slnext)
+    {
+      if (c->c_slperp)
+        count+=dump_canvas_scs(c, file);
+      else 
+        { 
+          count++;
+          p = Layer2Window(c->c_layer);
+          fprintf(file, "%s%d %d %d\n", (D_forecv==c) ? "f ":"",(p) ? p->w_number : -1, c->c_xe-c->c_xs+1,c->c_ye-c->c_ys+1);
+        }
+    }
+  return count;
+}
+
+int
+LayoutDumpCanvasScs(cv, filename)
+struct canvas *cv;
+char *filename;
+{
+  FILE *file = secfopen(filename, "a");
+  int count=0;
+  if (!file)
+    return 0;
+  fprintf(file,"%d %d\n%d %d\n",D_width, D_height, D_layout->lay_focusminwidth, D_layout->lay_focusminheight);
+  count=dump_canvas_scs(cv, file);
+  fprintf(file,"%d\n",count);
+  fclose(file);
+  return 1;
+}
+
diff --git a/src/layout.h b/src/layout.h
index 065edb7..3b79b0c 100644
--- a/src/layout.h
+++ b/src/layout.h
@@ -43,6 +43,8 @@ struct layout
   struct canvas   *lay_forecv;
   struct canvas   *lay_cvlist;
   int              lay_autosave;
+  int              lay_focusminwidth;
+  int              lay_focusminheight;
 };
 
 extern void  AutosaveLayout __P((struct layout *));
diff --git a/src/process.c b/src/process.c
index cb85adc..cb807bb 100644
--- a/src/process.c
+++ b/src/process.c
@@ -1275,6 +1275,28 @@ int key;
     case RC_DUMPTERMCAP:
       WriteFile(user, (char *)0, DUMP_TERMCAP);
       break;
+    case RC_DUMPSCREEN:
+      if (!strcmp(args[0], "window"))
+        {
+          int mode;
+          if (args[2] && !strcmp(args[2],"-F"))
+            mode = DUMP_SCSWINDOWFULL;
+          else
+            mode = DUMP_SCSWINDOW;
+          WriteFile(user, args[1], mode);
+        }
+      else if (!strcmp(args[0], "layout"))
+	{
+	  if (!display || !D_layout)
+	    OutputMsg(0, "Must have a display and a layout for 'dumpscreen layout'.");
+	  else if (!LayoutDumpCanvasScs(&D_canvas, args[1] ? args[1] : "layout-dump-size"))
+	    OutputMsg(errno, "Error dumping layout size.");
+	  else
+	    OutputMsg(0, "Layout dumped to \"%s\"", args[1] ? args[1] : "layout-dump-size");
+	}
+      else
+        OutputMsg(0, "Usage: dumpscreen [window|layout] filename [-F]");
+      break;
     case RC_HARDCOPY:
       {
 	int mode = DUMP_HARDCOPY;
@@ -1730,6 +1752,9 @@ int key;
         copy_reg_fn(&ch, 0, NULL);
       break;
 #endif
+    case RC_REGIONSIZE:
+       OutputMsg(0, "%d %d",D_forecv->c_xe-D_forecv->c_xs+1,D_forecv->c_ye-D_forecv->c_ys+1);
+       break;
     case RC_REGISTER:
 #ifdef ENCODINGS
       i = fore ? fore->w_encoding : display ? display->d_encoding : 0;
@@ -2676,6 +2701,19 @@ int key;
       MakeTermcap((display == 0));
       debug("new termcap made\n");
       break;
+    case RC_TTY:
+      if(fore)
+        {
+          if (fore->w_type == W_TYPE_TELNET)
+            OutputMsg(0, "telnet");
+          else if (fore->w_type == W_TYPE_GROUP)
+            OutputMsg(0, "group");
+          else
+            OutputMsg(0, "%s", fore->w_tty);
+        }
+      else
+        OutputMsg(0, "none");
+      break;
     case RC_ECHO:
       if (!msgok && (!rc_name || strcmp(rc_name, "-X")))
 	break;
@@ -3081,14 +3119,16 @@ int key;
       (void)ParseNum(act, &nwin_default.histheight);
       break;
     case RC_SCROLLBACK:
-      if (flayer->l_layfn == &MarkLf)
-	{
-	  OutputMsg(0, "Cannot resize scrollback buffer in copy/scrollback mode.");
-	  break;
-	}
-      (void)ParseNum(act, &n);
-      ChangeWindowSize(fore, fore->w_width, fore->w_height, n);
-      if (msgok)
+    if (*args != 0)
+	    {
+	  if (flayer->l_layfn == &MarkLf)
+	    {
+	      OutputMsg(0, "Cannot resize scrollback buffer in copy/scrollback mode.");
+	      break;
+	    }
+	  (void)ParseNum(act, &n);
+	  ChangeWindowSize(fore, fore->w_width, fore->w_height, n);
+      }
 	OutputMsg(0, "scrollback set to %d", fore->w_histheight);
       break;
 #endif
@@ -4224,19 +4264,21 @@ int key;
 	  else
             focusminheight = n;
 	}
-      if (msgok)
-	{
-	  char b[2][20];
-	  for (i = 0; i < 2; i++)
-	    {
-	      n = i == 0 ? focusminwidth : focusminheight;
-	      if (n == -1)
-		strcpy(b[i], "max");
-	      else
-		sprintf(b[i], "%d", n);
-	    }
-          OutputMsg(0, "focus min size is %s %s\n", b[0], b[1]);
-	}
+	char b[2][20];
+	for (i = 0; i < 2; i++)
+	  {
+	    n = i == 0 ? focusminwidth : focusminheight;
+	    if (n == -1)
+	      strcpy(b[i], "max");
+	    else
+	      sprintf(b[i], "%d", n);
+	  }
+	if (D_layout)
+	  {
+	    D_layout->lay_focusminwidth = focusminwidth;
+	    D_layout->lay_focusminheight = focusminheight;
+	  }
+        OutputMsg(0, "focus min size is %s %s\n", b[0], b[1]);
       break;
     case RC_GROUP:
       if (*args)
@@ -4252,13 +4294,10 @@ int key;
 	  WindowChanged((struct win *)0, 'W');
 	  WindowChanged((struct win *)0, 0);
 	}
-      if (msgok)
-	{
-	  if (fore->w_group)
-	    OutputMsg(0, "window group is %d (%s)\n", fore->w_group->w_number, fore->w_group->w_title);
-	  else
-	    OutputMsg(0, "window belongs to no group");
-	}
+    if (fore->w_group)
+      OutputMsg(0, "window group is %d (%s)\n", fore->w_group->w_number, fore->w_group->w_title);
+    else
+      OutputMsg(0, "window belongs to no group");
       break;
     case RC_LAYOUT:
       if (!strcmp(args[0], "title"))
diff --git a/src/screen.h b/src/screen.h
index 5c93f32..725a2cd 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -270,6 +270,8 @@ struct msg
 #define DUMP_HARDCOPY	1
 #define DUMP_EXCHANGE	2
 #define DUMP_SCROLLBACK 3
+#define DUMP_SCSWINDOW  7
+#define DUMP_SCSWINDOWFULL 8
 
 #define SILENCE_OFF	0 /* Not checking for silence */
 #define SILENCE_ON	1 /* Window being monitored for silence */
