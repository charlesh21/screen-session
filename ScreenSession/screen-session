#!/bin/sh
# file: screen-session
# author: Artur Skonecki
# website: http://adb.cba.pl
# description: screen-session tools starter
# it is necessary to run screen_saver.py embedded in other screen session to be able to run it from saved/loaded screen session

# Absolute path to this script. /home/user/bin/foo.sh
SCRIPT=$(/bin/echo $0|python -c 'import os,sys;i=sys.stdin.read();print os.path.realpath(i.strip())')
# Absolute path this script is in. /home/user/bin
SCRIPTPATH=`dirname $SCRIPT`

cd $SCRIPTPATH
VERSION=git
SCREEN_SESSION="SCREEN-SESSION ($VERSION) - collection of tools for GNU Screen.\n"

showhelp() {
    /bin/echo $SCREEN_SESSION
    /bin/echo -e "Usage: screen-session [mode] [options]\n\
Help: screen-session [mode] --help\n\
    \n\
Available modes:\n\
    save\t- save sessions to disk\n\
    load\t- load session from savefile\n\
    ls\t\t- list saved sessions\n\
    \n\
    manager\t- sessions manager with split screen preview\n\
    dir\t\t- start Screen window in the same working directory\n\
    regions\t- display number in each region (like tmux display-panes)\n\
    kill\t- send signal to last process started in a window\n\
    kill-zombie\t- kill all zombie windows in session
    grab\t- grab a process and attach it to current tty
    renumber\t- renumber windows to fill gaps 
    sort\t- sort windows by title
    "
}

showhelp_regions() {
    /bin/echo -e "Display number in each region\n\
script reassembling the functionality of tmux display-panes\n\
\nUsage: screen-session regions"
}

showhelp_kill() {
    /bin/echo -e "Kill last process started in a window\n\
\nUsage: screen-session kill [signal=TERM] [window=current]"
}

showhelp_kill_zombie() {
    /bin/echo -e "Kill all zombie windows in session\n\
\nUsage: screen-session kill-zombie [maxwin=MAXWIN] [minwin=0]"
}

showhelp_dir() {
    /bin/echo -e "Start a new Screen window in the same working directory\n\ 
on the position next to the current window\n\
\nUsage: screen-session dir [program]"
}

showhelp_grab() {
    /bin/echo -e "Grab a process and attach to the current tty.\n\
Works with applications without complicated output scheme\n\
\nUsage: screen-session grab [PID]\n\
on the previous shell type: $ disown"
}

showhelp_manage() {
    /bin/echo -e "Sessions manager for GNU Screen with preview in a split window\n\
\nUsage: screen-session manage"
}

showhelp_renumber() {
    /bin/echo -e "Renumber windows to fill the gaps\n\
\nUsage: screen-session renumber [maxwin=MAXWIN] [minwin=0]"
}

showhelp_sort() {
    /bin/echo -e "Sort windows by titles\n\
\nUsage: screen-session sort [maxwin=MAXWIN] [minwin=0]"
}

waitfor=0
nonest=0
logpipe=1

if [ $# -eq 0 ]; then
    showhelp
    exit 1
fi

mode=$1
shift 1 $*

# parse command line arguments
while getopts ":WNP:": OPT; do
    case "$OPT" in
    W)  
        waitfor=1
        ;;
    N)  
        logpipe=0
        ;;
    P)  
        logpipe=1
        ;;
    esac
done

if [ $# -ge 1 ]; then
    if [ $1 = "--help" -o $1 = "-h" ]; then
    /bin/echo $SCREEN_SESSION
        case "$mode" in
            manager) showhelp_manage
            ;;
            grab) showhelp_grab
            ;;
            dir) showhelp_dir
            ;;
            regions) showhelp_regions
            ;;
            kill-zombie) showhelp_kill_zombie
            ;;
            kill) showhelp_kill
            ;;
            renumber) showhelp_renumber
            ;;
            sort) showhelp_sort
            ;;
            save|load|ls) python ./screen_saver.py  $mode $*
            ;;
            *) /bin/echo "No such mode \"$mode\""
            ;;
        esac
        exit 0
    fi
fi

session=`python ./get_current_session.py`
if [ $mode = "manager" ]; then
    python ./manager.py p $session

elif [ $mode = "grab" ]; then
    sh ./screen-session-grab $*

elif [ $mode = "regions" ]; then
    screen -m -d -c /dev/null python ./screen-display-regions.py $session $*

elif [ $mode = "regions-helper" ]; then
    sh ./screen-display-regions-helper $*

elif [ $mode = "dir" ]; then
    python ./screen-in-dir.py $session $*

elif [ $mode = "kill" ]; then
    # screen-session kill [signal=TERM] [win=current]
    python ./kill.py $session $*

elif [ $mode = "kill-zombie" ]; then
    maxwin=`screen -X maxwin; screen -Q @lastmsg | python -c "import sys; print(sys.stdin.read().split(':',1)[1].strip())"`
    python ./kill-zombie.py $session $maxwin $*

elif [ $mode = "kill-group" ]; then
    python ./kill-group.py $session $*

elif [ $mode = "renumber" ]; then
    maxwin=`screen -X maxwin; screen -Q @lastmsg | python -c "import sys; print(sys.stdin.read().split(':',1)[1].strip())"`
    python ./renumber.py $session $maxwin $*

elif [ $mode = "sort" ]; then
    maxwin=`screen -X maxwin; screen -Q @lastmsg | python -c "import sys; print(sys.stdin.read().split(':',1)[1].strip())"`
    python ./sort.py $session $maxwin $*

elif [ $mode = "save" -o $mode = "load" -o $mode = "ls" -o $mode = "other" ]; then
    screen -X sessionname
    rawargument=`screen -Q @lastmsg`

    testargument=`screen -Q @tty`

    scsfiledir="/tmp/screen-sessions-$USER"
    scsfile="$scsfiledir/___scspipe-$$"

    argument0=""
    argument1=""

    if [ `/bin/echo ${testargument} | grep -c "^/dev"` -eq 1 ]; then
        argument1="--current-session $session"
    else
        /bin/echo "--- not running inside patched Screen, this session cannot be saved properly"
    fi

    argument0="logpipe=$scsfile"
    if [ $logpipe -eq 1 ]; then
        if [ ! -d "$scsfiledir" ]; then
            mkdir $scsfiledir
        fi
        if [ -d "$scsfile" ]; then
            rm $scsfile
        fi
        mkfifo $scsfile
        screen -m -d -c /dev/null python ./screen_saver.py $mode $argument0 $argument1 $* 
        
        cat $scsfile
        rm $scsfile
    else
        python ./screen_saver.py $mode $argument0 $argument1 $*
    fi
else
    showhelp
fi

if [ $waitfor -eq 1 ]; then
    /bin/echo 'Press any key...'
    stty cbreak -/bin/echo; KEY=$(dd bs=1 count=1 2>/dev/null); stty -cbreak echo
fi
